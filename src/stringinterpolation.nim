
import macros

# helper types to represent printf format string matches
type
  FormatStringMatchEnum = enum
    fsInvalid, fsPct, fsMatch

  FormatStringMatch = object
    case kind: FormatStringMatchEnum
    of fsMatch:
      s: string
    else:
      discard

proc len(m: FormatStringMatch): int =
  case m.kind:
  of fsInvalid: 0
  of fsPct: 1
  of fsMatch: m.s.len

proc typeSpecifier(m: FormatStringMatch): char =
  if m.kind == fsMatch:
    m.s[^1]
  else:
    '\0'


proc parseFormatString(s: string): FormatStringMatch =
  ## helper function tries to parse a printf format string
  ## from the beginning of ``s``.
  ##
  ## This is still completely stupid (only tests for the terminating character)
  ## In the long term I plan to add a more thorough validation of
  ## the format strings...
  if s[0] == '%':
    return FormatStringMatch(kind: fsPct)

  let terminating = {'d', 'i', 'u', 'f', 'F', 'e', 'E', 'g', 'G', 'x', 'X', 'o', 's', 'c', 'p', 'p', 'a', 'A', 'n'}

  for i, c in s:
    if c in terminating:
      return FormatStringMatch(kind: fsMatch, s: s[0..i])

  return FormatStringMatch(kind: fsInvalid)


proc extractFormatStrings(s: string): seq[FormatStringMatch] =
  ## extracts all printf format strings that are contained
  ## in ``s``.

  result = newSeq[FormatStringMatch]()
  var i = 0

  while i < s.len:
    let c = s[i]
    #echo s, i, c, result
    if c == '%':
      let m = parseFormatString(s[i+1..^1])
      if m.kind == fsMatch:
        result.add(m)
      i += m.len
    inc i





macro appendVarargs(c: expr, e: expr): expr =
  ## helper macro to wrap varargs of C calls.
  result = c
  for a in e.children:
    result.add(a)


proc snprintf(buffer: ptr cchar, n: csize, formatstr: cstring): cint
  {.importc: "snprintf", varargs, header: "<stdio.h>".}


template formatUnsafe*(formatString: string, args: varargs[expr]): string =
  ## performs a string formatting _without_ type checking. On the other hand,
  ## this allows to pass a formatString which is not a static literal.
  ## This means that it is possible to use dynamic string format strings, e.g.
  ## formatUnsafe("%" & $dynamicNumberOfDigits & "d", 1_000_000)

  # first call
  const initSize = 256
  var result = newStringOfCap(initSize)
  var written = appendVarargs(snprintf(cast[ptr cchar](result.cstring), initSize, formatString), args)
  let requiredSize = written + 1 # required size is +1 since the '\0' is not considered in 'written'

  if written < 0:
    raise newException(ValueError, "illegal format string \"" & formatString & "\"")
  elif requiredSize <= initSize:
    result.setlen(written)
  else:
    # second call required
    result = newStringOfCap(requiredSize)

    # call snprintf again (we can discard the size this time)
    written = appendVarargs(snprintf(cast[ptr cchar](result.cstring), requiredSize, formatString), args)
    result.setlen(written)

  result


macro format*(formatString: string{lit}, args: varargs[expr]): expr =
  ## formats a static format string, with arguments of variable type.
  ## This is a typesafe version of ``formatUnsafe``. Internally, it performs
  ## type checking and generates a call to ``formatUnsafe``.

  #echo formatString.strval
  let formatStrings = extractFormatStrings(formatString.strval)
  #echo formatStrings
  #echo formatStrings.len, " == ", args.len
  if formatStrings.len != args.len:
    error "number of varargs ("  & $args.len & ") does not match number of string formatters (" & $formatStrings.len & ")"

  result = newCall("formatUnsafe", formatString)

  var i = 0
  for fs in formatStrings:
    #echo i
    #echo args[i].treerepr
    let actualType = args[i].getType
    let atk = actualType.typeKind
    #echo "Actual Type: ", actualType.treerepr
    #echo "Actual Type Kind: ", atk

    let typeSpecifier = fs.typeSpecifier
    #echo "Type specifier: ", typeSpecifier

    type TypeMatchEnum = enum tmMatch, tmConvertToString, tmNoMatch

    proc checkIn(s: set[NimTypeKind]): TypeMatchEnum =
      if atk in s:
        tmMatch
      else:
        tmNoMatch

    let typeMatch = case typeSpecifier
      of 'c':
        checkIn({ntyChar})
      of 'd', 'i', 'x', 'X':
        # TODO: is this okay, we could type check if formatter has unsigned flag...
        checkIn({ntyInt, ntyInt8, ntyInt16, ntyInt32, ntyInt64, ntyUInt, ntyUInt8, ntyUInt16, ntyUInt32, ntyUInt64})
      of 'f', 'e', 'E', 'g', 'G':
        checkIn({ntyFloat, ntyFloat32, ntyFloat64, ntyFloat128})
      of 'p':
        # TODO: is this okay
        checkIn({ntyPtr, ntyRef}) 
      of 's':
        if atk == ntyString:
          tmMatch
        else:
          tmConvertToString
      else:
        tmNoMatch

    if typeMatch == tmNoMatch:
      error "string formatter '" & typeSpecifier & "' does not match type " & $atk # $symbol(actualType)
    elif typeMatch == tmConvertToString:
      add(result, prefix(args[i], "$"))
    else:
      add(result, args[i])

    inc i

  #echo " *** generated by 'format': ", result.treerepr






const
  Whitespace = {' ', '\t', '\v', '\r', '\l', '\f'}
  IdentChars = {'a'..'z', 'A'..'Z', '0'..'9', '_'}
  IdentStartChars = {'a'..'z', 'A'..'Z', '_'}
   ## copied from parseutils, which copied from strutils
   ## maybe these characters should be exported in a single place?


proc isValidExpr(s: string): bool {.compileTime.} =
  ## static helper function to check if an expression is valid
  try:
    discard parseExpr(s)
    return true
  except ValueError:
    return false


macro ifmt*(formatStringNode: string): expr =

  let formatString = formatStringNode.strVal

  type
    ParseState = enum
      psNeutral, psOneDollar, psIdent, psExpr

  var state = psNeutral
  var buffer = ""
  var i = 0

  var outFmtStr = ""
  var outArgs = newSeq[NimNode]()

  while i < formatString.len:
    let c = formatString[i]
    #echo c, " state: ", state
    case state

    of psNeutral:
      if c == '$':
        state = psOneDollar
        buffer.setlen(0) # clear buffer for ident/expr accumulation
        inc i
      elif c == '%':
        inc i
        if i < formatString.len and formatString[i] == '%':
          outFmtStr.add("%%")
          inc i
        else:
          error "format string contains an unescaped '%' character (use \"%%\" to escape)"
      else:
        outFmtStr.add(c)
        inc i

    of psOneDollar:
      if c == '$': # second dollar -> yield "$", return to neutral
        outFmtStr.add("$")
        state = psNeutral
      elif c == '{':
        state = psExpr
      elif c in IdentStartChars:
        state = psIdent
        buffer.add(c)
      else:
        error "a '$' character must either be followed by '$', an identifier, or a {} expression"
      inc i

    of psIdent:
      if c in IdentChars:
        buffer.add(c)
        inc i
      elif c == '%':
        outArgs.add(newIdentNode(buffer))
        let substr = formatString[i+1..^1]
        #echo "substr: ", substr
        let formatter = parseFormatString(substr)
        #echo "formatter: ", formatter

        case formatter.kind:
        of fsMatch:  # if we have a valid format string: append it and inc by '%' + formatter.len
          outFmtStr.add('%' & formatter.s)
          i += 1 + formatter.len
        of fsPct: # if the '%' char was actually an escaped double '%': provide default formatter + insert '%%'
          outFmtStr.add("%s%%")
          i += 1 + formatter.len # == 2, but written consistently
        of fsInvalid:
          error "could not parse format string '" & substr & "'"
        state = psNeutral
      else:
        outArgs.add(newIdentNode(buffer))
        outFmtStr.add("%s")
        state = psNeutral
        # note: we no _not_ increase i here
        # in order to parse the same character
        # again in neutral state, allowing to
        # check for '$'.

    of psExpr:
      if c == '}' and buffer.isValidExpr:
        outArgs.add(parseExpr(buffer))
        state = psNeutral
        inc i
        # peek into next char to see if we have a format string
        if i < formatString.len:
          let c = formatString[i]
          if c == '%':
            let substr = formatString[i+1..^1]
            #echo "substr: ", substr
            let formatter = parseFormatString(substr)
            #echo "formatter: ", formatter

            case formatter.kind:
            of fsMatch:  # if we have a valid format string: append it and inc by '%' + formatter.len
              outFmtStr.add('%' & formatter.s)
              i += 1 + formatter.len
            of fsPct: # if the '%' char was actually an escaped double '%': provide default formatter + insert '%%'
              outFmtStr.add("%s%%")
              i += 1 + formatter.len # == 2, but written consistently
            of fsInvalid:
              error "could not parse format string '" & substr & "'"
          else:
            # no explicit formatter: insert the default formatter
            outFmtStr.add("%s")
        else:
          # at end of string we have to insert the default formatter
          outFmtStr.add("%s")
      else:
        buffer.add(c)
        inc i


  # handle termination
  if state == psIdent:
    outArgs.add(newIdentNode(buffer))
    outFmtStr.add("%s")
  elif state == psOneDollar:
    error "format string is not properly terminated (trailing '$')"
  elif state == psExpr:
    error "format string contains an invalid or incomplete expression \"{" & buffer & "\""

  # generate call to "format" template and add arguments
  result = newCall("format", newStrLitNode(outFmtStr))
  for arg in outArgs:
    result.add(arg)

  #echo " *** outFmtStr: ", outFmtStr
  #echo " *** outArgs: ", outArgs.repr
  #echo " *** generated by 'ifmt': ", result.treeRepr





when isMainModule:

  import unittest

  suite "stringinterpolation":

    test "parseFormatString":
      # since I had to drop regular expressions from
      # parseFormatString, not all tests work.
      # In fact, the currect implementation only checks
      # for the terminating type specifier. TODO...
      let tests = [
        ("%asdf", fsPct, 1),
        ("ddd", fsMatch, 1),
        (" d", fsMatch, 2),
        (" +-0#d", fsMatch, 6),
        ("f", fsMatch, 1),
        ("d", fsMatch, 1),
        ("s", fsMatch, 1),
        ("5f", fsMatch, 2),
        ("5.1f", fsMatch, 4),
        (".2f", fsMatch, 3),
        ("50.20f", fsMatch, 6),
        #("5.2.2f", fsInvalid, 0), # only one decimal separator allows
        #("5.f", fsInvalid, 0), # the decimal separator must be followed by digits
        ("zu", fsMatch, 2),
        #("zzu", fsMatch, 1), # length specifier must not be repeated
        ("hhd", fsMatch, 3), # "hh" is a valid length specified
        #("hhhhd", fsInvalid, 0), # but must not be repeated
      ]
      for s, expectedKind, expectedLen in tests.items:
        let m = parseFormatString(s)
        #echo "Expression: '", s, "' => ", m, " match len: ", m.len
        check m.kind == expectedKind
        check m.len == expectedLen


    test "formatUnsafe":
      check formatUnsafe("") == ""
      check formatUnsafe("", 1) == ""
      check formatUnsafe("%%") == "%"
      
      let s = formatUnsafe("%3d %8.3f%%", 42+1, 3.14 * 2)
      check s == " 43    6.280%"
      check s.len == 13

      var digits = 15
      check formatUnsafe("%" & $digits & "d", 1_000_000) == "        1000000"

      expect ValueError:
        discard formatUnsafe("%")

      # can I check for SIGSEGV?
      # check formatUnsafe("%s") == ""


    test "format":

      # everything must convert to string
      check format("%s", 1) == "1"
      check format("%s", 1.0) == "1.0"
      check format("%s", @[1,2,3]) == "@[1, 2, 3]"
 
      let s = format("%12d %s %s %5.3e", 42.int16, 3.14*1.0, @[1,2,3], 1.234)
      check s == "          42 3.14 @[1, 2, 3] 1.234e+00"
      
      # these must be compliation errors due to type errors
      when compiles(format("hello %d", "a string")):
        check false
      when compiles(format("hello %f", "a string")):
        check false
      when compiles(format("hello %f", 1)):
        check false
      when compiles(format("hello %d", 1.0)):
        check false

    test "ifmt":

      let x = 1
      let s = "test"
      
      check ifmt" %% test x = $x%d$x%5s$x%%$x%%" == " % test x = 1    11%1%"
      check ifmt"%%${x+1}%5d${x+2}%s${3+x}%%$$$x$$" == "%    234%$1$"
      check ifmt"""${"test"}""" == "test"
      check ifmt"""${s}""" == "test"
      
      check ifmt"""${s & "{}"}""" == "test{}"

      # these must be compliation errors
      when compiles(ifmt"a single %"):
        check false
      when compiles(ifmt"trailing $"):
        check false
      when compiles(ifmt"an open ${expr"):
        check false
      when compiles(ifmt"a wrong identifier $doesNotExist"):
        check false
      when compiles(ifmt"a bad expression ${or}"):
        check false

